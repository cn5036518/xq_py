#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/11/4 6:58
#@author:wangtongpei

''''''
'''
二分法查找，递归方法1，伪代码思路
1、每次递归调用会新产生一个新的列表（是原来列表长度的一半）
2、先定义左右边界的索引号-下标，以及中位数的索引号-下标

条件是left<=right  #注意：必须加上等于
3、当目标数大于中位数的时候,新的列表切片li2 = li1[mid+1:]
    递归调用自己
4、当目标数小于中位数的时候,新的列表切片li2 = li1[:mid]
    递归调用自己
5、当目标数等于中位数的时候,找到了

如果left<right
6、上述3,4，5都执行完毕，没有找到的话，返回-找不到

注意点：
1、递归的入口前面需要return
    原因：实现第5次递归调用的返回值，会依次传递给第1次递归调用
2、二分法的适用场景
    列表必须是已经排序后的

缺点：
变动的是列表，每次产生一个新列表（元素是之前列表的一半）
1、得不到目标数的索引号-下标-位置
    因为每次都切了一半，产生了一个新的列表
2、比较浪费内存空间
    因为每次递归调用，都会产生一个新的列表
    比如：1亿元素的列表，第1次递归调用，就新产生了一个5000万的列表
                       第2次递归调用，就新产生了一个2500万的列表。。。依次类推
'''


def recursion1(n,li):
    left = 0  #1 定义左边界的索引号-下标-位置
    # right = len(li1)-1
    right = len(li)-1  #注意3：拼写错误，是li而不是li1
    #2 定义右边界的索引号-下标-位置

    if left<=right: #3 左边界位置小于等于右边界的位置
        #注意4：需要包含等于=
        # middle = (right - left) // 2  # 整除 中位数的索引号-下标
        middle = (right + left) // 2  #5 注意1： 求中位数 是+ 而不是 -
        if n>li[middle]: #6 如果目标数大于中位数
            li2 = li[middle+1:]  # 9 新产生一个新列表，长度是之前的一半（左边界变了）
            # 注意4： +和:的优先级 #冒号的优先级高于+
            return recursion1(n,li2)  #10 参数1是目标数不变，参数2是新列表（变了）
            # 注意5： 递归调用自己 前面加return  递归入口
        elif n<li[middle]: #7 如果目标数小于中位数
            # li3 = li[:middle]  #
            li2 = li[:middle]  #11 新产生一个新列表，长度是之前的一半（右边界变了）
            # 注意2：这里是li2 而不能是li3 必须是同一个列表才对（和上面的分支）
            return recursion1(n,li2)  # 12 参数1是目标数不变，参数2是新列表（变了）
        else: #8 如果目标数等于中位数
            print('%s 找到了' % n)
            return True  #13 找到了 返回True
    else:  #4 如果左边界位置大于右边界的位置
        print('%s 找不到' % n)
        return False #14 找不到 返回False

li1 = [1,2,3,4,5,6]
n = 7
ret1 = recursion1(n,li1) #参数1是目标数，参数2是列表（查找范围）
if ret1:
    print('%s 找到了-' % n)
else:
    print('%s 找不到-' % n)















