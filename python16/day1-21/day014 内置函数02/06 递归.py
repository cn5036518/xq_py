#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/11/2 15:43
#@author:wangtongpei

def func():
    print('我要调用自己哈')
    func() #递归的入口

# func() #报错
#RecursionError: maximum recursion depth exceeded while calling a Python object

'''
1、为什么会出现报错？
--即为什么在递归的过程中，最后会提示：已经到了最大的递归深度？

原因：
因为第一次调用自己的时候，会在内存开辟一个局部空间
第二次调用自己的时候，会在第一个局部空间中开辟第2个局部空间
第3次调用自己的时候，会在第2个局部空间中开辟第3个局部空间
。。。以此类推，第n次调用自己的时候，无法在第n-1个局部空间中开辟第n个局部空间了
（因为内存空间不够用了，无法再次开辟-分配了）

官网说明：递归的最大深度是1000，但是到不了1000，可能是998 996和操作系统有关系（一般是996-998）
        比如：win8和win10可能不同  比如：win8是996 win10是998

类比：一开始的内存空间是4，接着就是3，2,1,1/2,1/3,1/4。。。最后就会到0

2、递归的概念：函数定义中，自己调用自己
   递归的缺点：比较占用内存空间（凡是涉及重新开辟内容空间的，都很耗时费力）
                开辟内存空间 类比：开荒（开垦荒地）
   递归的优点：写起来简单，适合树形结构（树干-树枝-树叶）的遍历
              比如：1、遍历文件夹（很少有文件夹的目录层级超过10层）
                    2、家族（小明的爷爷-小明的爸爸-小明）
                    3、公司结构(ceo-vp-总监-经理-主管-员工)
   树形解构的遍历过程：
   1、从1个树干找到2个树枝节点
   2、2个树枝节点继续作为树干，又延伸出2个叶子节点

   二叉树遍历的伪代码：
   def func(root):
       left = root.left  #目前还没有实现
       right = root.right
       func(left)   #递归
       func(right)

'''

#需求:数数，用递归实现1,2,3，。。。100
def func1(n):
    print(n)
    func1(n+1)
    # if n ==100:
    #     return

# func1(1)

#修改递归的深度
import sys
###### sys.setrecursionlimit(1100)  #将递归深度从默认的1000改成1100  不建议修改这个深度
#实际运用递归过程中，很少超过10层，如果超过10层，建议不要使用递归













