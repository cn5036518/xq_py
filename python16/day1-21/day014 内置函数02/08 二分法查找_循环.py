#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/11/3 6:48
#@author:wangtongpei

#需求 如何判断数字3是否在列表中
#方法1 遍历循环列表
li1 = [1,2,3,4]
for i in li1:
    if i==3:
        print('3在列表中')
        break
else: #如果for循环正常结束，如果有break就不会执行整个else
    print('3不在列表中')
#这个时间复杂度是O（n），这个n是列表的长度，即时间复杂度和列表的长度呈正比
#列表的长度是多少，就需要比较多少次
print('----------------------1 遍历循环')

#方法2 二分法查找--常规写法--条件循环while
'''
二分法查找算法
优点：效率非常高
    1、比如：1亿个元素的列表，循环遍历，需要比较1亿次
    2、如果是二分法，需要比较2的27次方大约是1.3亿，即只需要比较27次即可（比较次数相差近400万倍）
        二分法的对比范围从64-32-16-8-4-2-1 每次比较，都会将对比范围缩小一半
缺点：必须是有序序列，先要排序--sorted

二分法伪代码思路
前提：列表已经做了排序-从小到大
1、获取中位数的索引号-下标
2、拿目标数和列表的中位数进行比较
    1、如果比中位数小，就在中位数的左边，右边界索引号变成了中位数索引号-下标减1
    2、如果比中位数大，就在中位数的右边，左边界索引号变成了中位数索引号-下标加1
3、上述循环退出的条件是
    1、找到了break，打印出其索引号-下标
    2、没有找到，循环正常结束，提示-没有找到-else
    3、当左边界的索引号>=右边界的缩影好-下标（条件循环，用while）
'''
li1 = [0,1,2,3,4,5,6,7,8,9]
left = 0  #初始左边界的索引号-下标
right = len(li1)-1   #初始右边界的索引号-下标

n=3  #定义要找的目标数
while left<=right: #条件循环，条件是左边界小于等于右边界的下标（如果左边界大于右边界的下标，就停止循环了）
# while left<right: #条件循环，条件是左边界小于等于右边界的下标（如果左边界大于右边界的下标，就停止循环了）
    #注意:这里是小于等于，而不是小于；小于会漏掉一种情况(就是left和right都是3，相等-循环结束了，
    #实际上，left和right相等就是找到了，索引号就是3，而不应该跳出循环) 这个是边界值
    # 小结：大概思路是对的，但是结果验证是不对的，就需要微调边界值了
    middle = (left + right) // 2  # 中位数的索引号-下标
    # 用整除//而不是除号/的原因是：索引号是整数，不能是小数
    # print(middle)
    #随着left和right的不断改变，middle的值也在随之改变
    if n<li1[middle]:  #1如果目标数小于中位数
        right = (middle-1) #2右边界的索引号-下标变成了中位数的下标-1
        # print(right)  #3
    elif n>li1[middle]: #3如果目标数大于中位数
        left = (middle + 1) #4左边界的索引号-下标变成了中位数的下标+1
        # print(left)  #3
    else: #5 如果目标数和中位数相等
        print('找到了，该数在列表中的索引号-下标是 %s' % middle) #6 打印-找到了，目标数的下标
        break #7 跳出整个循环
else: #8 当循环正常结束，即没有break的时候，提示没有找到
    print('%s 在列表中没有找到' % n)
print('----------------------2 二分法查找--常规写法--条件循环while')
'''
排错小结：
while中left和right的条件判断，是小于等于，而不是小于；
小于会漏掉一种情况(就是left和right都是3，相等-循环结束了，
实际上，left和right相等就是找到了，索引号就是3，而不应该跳出循环
这个等于是边界值（临界值）

归纳：大体思路是对的，但是结果验证是不对的，就需要微调边界值了
    根据反馈，调试程序就是在刻意练习重复的过程

二分法中，如果列表的有多个相同的元素，那么目标数的索引号不一定是最左边的那个元素的索引号
（这个和循环遍历列表不同，循环遍历的话，返回的索引号就是最左边的）
li1 = [1,2,2,2,2,4,4,4,4,5]
'''

#方法3 二分法查找--递归写法1
'''
方法论小结：
1、当遇到不好理解的地方，怎么办？
    1、放慢（一倍或者一倍以上）速度，反复听几次，反复练习几次
    2、听的时候，多暂停，多停下来思考，想明白了，再继续
       当思考速度慢于接收速度太多的时候，一定要暂停，
       让思考跟上接收的速度

2、递归的返回
    1、比如一共是5次递归，那么第5次递归的返回值，会给到第4次调用
        但是函数最后的返回值，是第2次递归的返回值，会给到第1次调用
        也就是说，函数最后的返回值是第2次递归的返回值，而不是第5次递归的返回值
        （第5次递归的返回值和第2次递归的返回值，是不一样的）
    2、如何让第5次递归的返回值和第2次递归的返回值一样呢
       答案是：让第5次递归的返回值先给到第4次调用，然后给到第3次调用
               接着给到第2次调用，最后给到第一次调用，连续传递
               语法是：在递归的入口前面加上return即可

3、方法3的缺点
    方法3变动的是列表，每次产生一个新列表（元素是之前列表的一半）
    1、得不到目标数的索引号-下标-位置
        因为每次都切了一半，产生了一个新的列表
    2、比较浪费内存空间
        因为每次递归调用，都会产生一个新的列表
        比如：1亿元素的列表，第一次递归调用，就新产生了一个5000万的列表
                           第2次递归调用，就新产生了一个2500万的列表.。。依次类推

4、方法4
    列表不变（不新产生列表），变动的是左右边界的索引号-下标-位置
'''
def func3():
    len('hello')
ret1 = func3()
print(ret1)  #None

def func4():
    return len('hello')
    #要得到长度5，在len('hello# ')前面加上return即可
    #同理，递归的入口也是一样 要想让第3次递归调用返回值给到第1次调用
    # 过程是：第3次递归调用返回值给到第2次调用，第2次调用返回值再给到第1次调用
    #即 在递归调用的入口前 加上return，从而实现连续传递返回值
ret2 = func4()
print(ret2)  #5
print('----------------------3 二分法查找--递归写法1--产生新列表1')











