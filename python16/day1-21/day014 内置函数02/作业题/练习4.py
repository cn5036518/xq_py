#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/11/8 5:49
#@author:wangtongpei

# 9,有下列三种数据类型
# 	l1 = [1,2,3,4,5,6]
# 	l2 = ['oldboy','alex','wusir','太白','日天']
# 	tu = ('**','***','****','*******')
# 写代码，最终得到的是（每个元组第一个元素>2,第三个*至少是4个）
# 	[(3, 'wusir', '****'), (4, '太白', '*******')]这样的数据。

l1 = [1,2,3,4,5,6]
l2 = ['oldboy','alex','wusir','太白','日天']
tu = ('**','***','****','*******')

'''
思路
1、列表1和列表2和列表3的同位置元素，组成元组，元组作为新列表的元素
    一一对应-map，  zip
2、且列表1的元素都大于2-filter
3、且列表3的元素至少是4个星-filter

步骤：
1、先普通函数
2、后匿名函数
'''

#1 3个列表的同位置元素组成的元组--zip
print(list(zip(l1,l2)))
#[(1, 'oldboy'), (2, 'alex'), (3, 'wusir'), (4, '太白'), (5, '日天')]
li3 = list(zip(l1,l2,tu))  #zip支持3个参数
print(li3)
#[(1, 'oldboy', '**'), (2, 'alex', '***'), (3, 'wusir', '****'), (4, '太白', '*******')]
print('------------------------------0 ')

#方法1 普通函数1
def func4(tu1):
    if tu1[0] > 2 and len(tu1[-1]) >=4: #条件判断
        #元组的第一个元素大于2，元组的最后一个元素的长度大于等于4
        return tu1
it4 = filter(func4,li3) #这里列表的每一个元素都是一个元组
#将列表的每一个元素作为参数，依次传递到普通函数，进过条件筛选后，返回符合条件的参数组成的迭代器
li4 = list(it4) #迭代器转成列表
print(li4) #[(3, 'wusir', '****'), (4, '太白', '*******')]
print('------------------------------1 filter+普通函数1 ')

#方法2 普通函数2
def func6(tu1):
    return tu1[0] > 2 and len(tu1[-1]) >=4
    #把上面方法1的条件，作为返回值（实际上，返回的是符合筛选条件的参数组成的迭代器）
it6 = filter(func6,li3)
li6 = list(it6) #迭代器转成列表
print(li6) #[(3, 'wusir', '****'), (4, '太白', '*******')]
print('------------------------------2 filter+普通函数2 ')

# 1-2、返回值--关键点
#     filter最终返回的是普通函数（或者匿名函数）的参数（符合条件）组成的迭代器（可转成列表）
#     map最后返回的是普通函数（或者匿名函数）的返回值组成的迭代器（可转成列表）

#方法3 匿名函数
l1 = [1,2,3,4,5,6]
l2 = ['oldboy','alex','wusir','太白','日天']
tu = ('**','***','****','*******')

#1 3个列表的同位置元素组成的元组--zip
print(list(zip(l1,l2)))
#[(1, 'oldboy'), (2, 'alex'), (3, 'wusir'), (4, '太白'), (5, '日天')]
li3 = list(zip(l1,l2,tu))  #zip支持3个参数
print(li3)
#[(1, 'oldboy', '**'), (2, 'alex', '***'), (3, 'wusir', '****'), (4, '太白', '*******')]

it5 = filter(lambda tu1:tu1[0] > 2 and len(tu1[-1]) >=4,li3)
# 把上述方法2中 普通函数的参数和返回值 填入匿名函数的冒号前后
li5 = list(it5) #迭代器转成列表
print(li5) #[(3, 'wusir', '****'), (4, '太白', '*******')]
print('------------------------------3 filter+匿名函数1 ')

#方法4 匿名函数--一行
l1 = [1,2,3,4,5,6]
l2 = ['oldboy','alex','wusir','太白','日天']
tu = ('**','***','****','*******')

print(list(filter(lambda tu1:tu1[0]>2 and len(tu1[-1])>=4,zip(l1,l2,tu))))
# (3, 'wusir', '****'), (4, '太白', '*******')]
print('------------------------------4 filter+匿名函数2 一行完成')
'''
zip(l1,l2,tu)这个是iterator（iterator也是属于iterable）
'''


'''
方法论小结：
1、用filter函数的时候，先写普通函数
   函数内是if 条件判断 + return
2、将普通函数修改一下
    函数内直接返回判断条件
    return + 条件判断  形成普通函数2
3、将上述普通函数2的
   参数和返回值  填入匿名函数
上述filter或者map先写普通函数，然后写匿名函数的方法就是：
1、不跳步骤
2、写普通函数的时候，就是在整理思路
   思路明确了，匿名函数只需要翻译即可

知识点小结：
01返回值--关键点1
    filter最终返回的是普通函数（或者匿名函数）的参数（符合条件）组成的迭代器（可转成列表）
        --filter对参数做了if条件筛选
            可以return参数
            也可以return筛选条件（if后的）
    map最后返回的是普通函数（或者匿名函数）的返回值组成的迭代器（可转成列表）
        --map对参数没有做if条件筛选，而是做了批量修改或者2个列表的同位置运算等

02运行原理--关键点2
    filter是把iterable中的每一个元素作为参数，依次传递到自定义函数（匿名函数），
        返回值是普通函数的参数（符合条件的--即对参数进行了条件筛选）组成的迭代器（可转成列表）
    map是把iterable中的每一个元素作为参数，依次传递给自定义函数（匿名函数），
        返回值是普通函数（或者匿名函数）的返回值组成的迭代器（可转成列表）
        map和filter的区别在于：
          1、map没有对参数进行if条件筛选，返回参数组成的迭代器（可转成列表)
          2、而是对参数进行了批量操作（比如：批量增加）
            或者多个列表的同位置元素的相加等运算
            返回的是返回值组成的迭代器（可转成列表）

03zip函数
    1、zip函数的参数可以是2个列表，也可以是2个以上列表（比如3个）
    2、支持2个及2个以上列表的同位置元素组成元组，元组作为新列表的元素
'''







