#!/usr/bin/env python
#-*- coding:utf-8 -*-

# 2. 给出一个纯数字列表. 请对列表进行排序(升级题).   #冒泡排序
# 思路:
# 1. 完成a和b的数据交换. 例如, a = 10, b = 24 交换之后, a = 24, b = 10
# 2. 循环列表. 判断a[i]和a[i+1]之间的大小关系, 如果a[i]比a[i+1]大. 则进行互换.
# 循环结束的时候. 当前列表中最大的数据就会被移动到最右端.
# 3. 想一想, 如果再次执行一次上面的操作. 最终第二大的数据就移动到了右端.
# 以此类推. 如果反复的进行执行相应的操作. 那这个列表就变成了一个有序列表.

li1 = [1,3,2,4,0]
for i in range(len(li1)-1):  #0-3 外循环是4次
    #  #注意点：这里的减1 -1；这里5个数，外循环4次，就已经排好序了，第5次循环不用再进行了
    flag = False  #1 优化点2，当列表排序已经从小到大了，就没有互换了，一旦没有互换，就可以退出外循环
    for j in range(len(li1)-1-i):
        #-1解决j+1越界
        # -i是优化点1，最大（次大的，倒数第三大的）的已经在最右边了，不需要再次内循环了
        if li1[j] > li1[j+1]:
            li1[j],li1[j+1] = li1[j+1],li1[j]
            #对列表本身进行修改，需要用到索引号遍历
            flag = True#  如果有互换，就修改标记位
    if flag == False:  #如果标记位没有修改，说明没有互换，说明列表排序已经从小到大，就退出外循环
        break #退出外循环
    """
    过程分析：
    第一次外循环 内循环循环0-3 循环4次 5个数，相邻数两两对比大小，比较4次，最大数在最右边
    第二次外循环 内循环循环0-2 循环3次 4个数，相邻数两两对比大小，比较3次，最大数之前已经在最右边（不需要两两比对）
                                            次大数在右边倒数第二个
    第三次外循环 内循环循环0-1 循环2次 3个数，相邻数两两对比大小，比较2次，最大数和此大数之前已经在最右边2位（不需要两两比对）
                                            倒数第三大的数在右边倒数第三个
    第四次外循环 内循环循环0 循环1次 2个数，相邻数两两对比大小，比较1次，最大数和此大数、倒数第三大数之前已经在最右边3位
                                （不需要两两比对） 倒数第四大的数在右边倒数第四个（5个数，就是顺数第二个）

    """
print(li1)












