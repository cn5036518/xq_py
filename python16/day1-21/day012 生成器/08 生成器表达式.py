#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/10/7 8:31
#@author:wangtongpei

''''''
'''
1、列表推导式 [结果       for循环 if筛选]
2、字典推导式 {key:value  for循环 if筛选}
3、集合推导式 {key        for循环 if筛选}

4、元组没有推导式
5、生成器表达式
gen = (i for i in range(10))

新建生成器对象-generator的两种方式
1、生成器函数名()
   生成器函数概念：函数中包含yield的函数，就叫生成器函数
2、通过生成器表达式
   生成器表达式格式  (结果 for循环)

生成器对象的特点
1、生成器的本质是迭代器，所以支持直接for循环   for i in gen:
2、生成器可以通过调用方法__next__()进行单次向下取值

生成器表达式和列表推导式的区别
1、列表推导式：一次性将所有元素都放到列表中（一次性将所有数据都创建出来），
              容易出现内存浪费（类比：一次生产10000件衣服，需要库存；鸡蛋）
2、生成器表达式：记录一下代码。每次需要的时候，取生成器表达式中执行一次这个代码。（类比：母鸡）
    1、节省内存
    2、惰性（每次调__next__()才会取值一次）
    3、只能向前，不能后退（生成一次后，不能生成第二次了，类比：弹夹没有子弹了）

'''

gen = (i for i in range(3))  #生成一个生成器对象
print(gen)  #<generator object <genexpr> at 0x00000000027FACF0>
print(gen.__next__())  #0

for i in gen:
    print(i)
print('-------------------1')

#2生成器函数产生的生成器，转换成列表的时候list（gen）--是将生成器函数的返回值（yield后的值222，放入空列表），结果是[222]
def func():
    print(111)
    yield 222  #暂停，返回
gen = func()  #生成器函数，产生一个生成器对象1  没有__next__()就没有向下取值
print(gen)  #<generator object func at 0x000000000259AD80>
print(list(gen))  #关键点：这个list(g)--把生成器对象转换成列表对象的动作 完成的是把生成器函数返回的值（yield后面的222）
#放入空列表中  即[222]
print(list(gen))  #[]  生成器第一次已经把yield的返回值222添加到了空列表，[222]，无法第二次生成222了（类比：弹夹没子弹了）
#关键点2
print('-------------------2-1 生成器函数产生的生成器，转换成列表的时候--是将生成器函数的返回值'
      '（yield后的值222，放入空列表），结果是[222]')

#3生成器表达式产生的生成器，转换成类表的时候list（gen）
# 是将生成器表达式中for循环的结果，依次添加到空列表[0,1]
gen2 = (i for i in range(2))  #这个gen是生成器
print(gen2)  #<generator object <genexpr> at 0x00000000025CAF30>  生成器
print(list(gen2))  #[0, 1]  #第一次 生成器产生的0,1已经依次添加到都了空列表[0,1]  关键点1
print(list(gen2))  #[]  #第二次 生成器不会再次产生0,1了，所以空列表还是[]   关键点2
#生成器只能向前，生成一次，就无法再生成第二次了（类比：弹夹的子弹打完了，就没子弹了）
print('-------------------2-2 生成器表达式产生的生成器，转换成类表的时候list（gen）'
      ' 是将生成器表达式中for循环的结果，依次添加到空列表[0,1]')


# #面试题1--笔试题
def func():
    print(111)
    yield 222  #暂停，返回
g = func()  #生成器函数，产生一个生成器对象1  没有__next__()就没有向下取值
print(g)

g1 = (i for i in g)  #生成器表达式1   产生一个生成器对象2  没有__next__()就没有向下取值
g2 = (i for i in g1)  #生成器表达式1   产生一个生成器对象3 没有__next__()就没有向下取值

print(list(g)) #g把生成器函数返回值（yield后面的222）-即第一次生成222，添加到空列表后，是[222]

print(list(g1)) #g1找g取值，g已经生成一次222了，不能第二次生成222（类比：弹夹没子弹了），所以g没值，g1就是空列表[]

print(list(g2)) #g2找g1取值,g1找g取值，g已经生成一次222了，不能第二次生成222（类比：弹夹没子弹了），
# 所以g没值，g1也没值，g2是空列表[]

print('-------------------3 面试题 生成器2次传递')

# #面试题--笔试题
def func():
    print(111)
    yield 222  #暂停，返回
g = func()  #生成器函数，产生一个生成器对象1  没有__next__()就没有向下取值
# print(g)

g1 = (i for i in g)  #生成器表达式1   产生一个生成器对象2  没有__next__()就没有向下取值
g2 = (i for i in g1)  #生成器表达式1   产生一个生成器对象3 没有__next__()就没有向下取值

print(list(g1)) #g1找g取值，g把yield返回的222，添加到空列表中[222]，第一次生成222之前，会打印111

print(list(g2)) #g2找g1取值，g1找g取值，g的222已经生成一次了，不能生成第二次了，所以g没值，g1页没值，g2是空列表[]

print(list(g)) #g的值222已经生成一次了，给到了g1，g不会第二次生成222了，所以g没值，是空列表[]

print('-------------------3-2 面试题 生成器2次传递 换顺序')













