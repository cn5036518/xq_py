#!/usr/bin/env python
#-*- coding:utf-8 -*-
#@time:  2019/10/6 10:16
#@author:wangtongpei

''''''
'''
生成器解决的问题：
1、一万件衣服一次性全部生产出来后，需要有地方存放--占用内存
2、最好是我需要一件，就马上生产一件，这样就不需要专门腾位置存放了--节约内存

生成器的概念：
1、生成器的本质是迭代器，写法和迭代器不一样，但是用法和迭代器是一样的
2、函数内含有yield关键字的函数，叫做生成器函数
3、yield关键字和return一样，都是可以返回值的
    1、yield和return的不同点：
        return在函数中，表示函数的终止，函数内return后面的代码是不运行的
        yield在函数中，表示函数的暂停，生成器函数内yield后面的代码暂停后，还是可以继续运行的

生成器的特点：
1、节省内存-占用很少内存
    比如：数据库有100w数据，只需要每次展示50条给用户即可，就可以用到生成器
2、惰性-每次调用__next__()才会取值一次
3、只能向前，不能后退

生成器的例子类比
1、一次把这辈子要吃的鸡蛋全买了，家里没地方放，保质期也有问题
2、解决办法：买个老母鸡（可以下蛋，类比--生成器）
生成器优点：对程序的效率提升非常大

'''

#1 生成器函数的例子
def func():
    print('我是函数1')
    yield "我是函数1的返回值"  #yield关键字和return一样，都是可以返回值的

ret = func()  #生成器函数后加()后，生成器函数没有执行，而是生成一个生成器对象
print(ret)  #<generator object func at 0x000000000268ACF0>
ret2 = ret.__next__()  #我是函数1  #生成器对象后面加上__next__()方法后，才是生成器函数的执行
print(ret2)  #我是函数1的返回值  获取到生成器函数的返回值
print('-------------------1 生成器函数')

#2 生成器函数-yield关键字
def func2():
    print('打开手机')
    print('打开陌陌')
    yield '手机'   #yield是暂停，return是终止 yield相当于把函数进行分段执行
    print('约妹子')
    print('出来喝喝茶')
    yield '电脑'
    print('哈哈')
gen = func2()   #生成器函数后加()后，生成器函数没有执行，而是生成一个生成器对象
print(gen)  #<generator object func at 0x000000000268ACF0>

ret2 = gen.__next__()  #打开手机  打开陌陌
#注意点：第一个__next__()是找到第一个yield
print(ret2)  #手机

# ret3 = ret2.__next__() #约妹子  出来喝喝茶  #报错
#AttributeError: 'str' object has no attribute '__next__'
ret3 = gen.__next__() #约妹子  出来喝喝茶  #注意ret2会报错，gen才是对的
#注意点：第二个__next__()是找到第二个yield
print(ret3)  #电脑

# ret4 = gen.__next__()  #找第三个yiels，如果找不到的话，就会报错StopIteration,
# #第三个yield前面的 哈哈 还是会执行打印
# print(ret4)
print('-------------------2 yield关键字 暂停')

#3 生产100件衣服--传统方式
def func1():
    li1 = []
    for i in range(1,101):
        li1.append('衣服 %s' % i)
    print(li1)  #生产出来了100件衣服，存在库房中了，占用内存
# func1()
print('-------------------3 生产100件衣服--传统方式')

#4 生产100件衣服--生成器模式（要一件生产一件，不占用库房，节约内存）--正确写法  推荐
def func2():
    for i in range(1,101):
        yield ('衣服 %s' % i)
gen = func2()  #生成器函数后面加()，不是函数执行，而是产生一个生成器对象（类比：订单）
print(gen.__next__()) #衣服 1   #生产第1件衣服  第1次返回
print(gen.__next__()) #衣服 2   #生产第2件衣服  第2次返回
print(gen.__next__()) #衣服 3   #生产第3件衣服  第3次返回
print(gen.__next__()) #衣服 4   #生产第4件衣服  第4次返回
print('-------------------4 生产100件衣服--生成器方式--正确写法')

#5 生产100件衣服--生成器模式（要一件生产一件，不占用库房，节约内存）--错误写法
def func2():
    for i in range(1,101):
        yield ('衣服 %s' % i)
# gen = func2()  #生成器函数后面加()，不是函数执行，而是产生一个生成器对象（类比：订单）
print(func2().__next__()) #衣服 1   #生产第1件衣服  第1次返回
#注意：fun2()每执行一次，都会产生一个新的生成器（类比：下了一个新的订单）
#类比：鸡蛋和母鸡  每次买个老母鸡，下一个蛋，母鸡就不要了；下次要吃鸡蛋，再买一个老母鸡，再下蛋。。。

print(func2().__next__()) #衣服 1   #生产第1件衣服  第2次返回
print(func2().__next__()) #衣服 1   #生产第1件衣服  第3次返回
print(func2().__next__()) #衣服 1   #生产第1件衣服  第4次返回
print('-------------------5 生产100件衣服--生成器方式--错误写法')

#6 生产100件衣服--生成器模式（要一件生产一件，不占用库房，节约内存）--正确写法  推荐2
def func2():
    for i in range(1,101):
        yield ('衣服 %s' % i)
gen = func2()  #生成器函数后面加()，不是函数执行，而是产生一个生成器对象（类比：订单）

# for i in range(20):  #方式1
#     print(gen.__next__())  #一次要100件衣服中的20件

for i in range(100):  #方式2
    if i == 20:
        break
    print(gen.__next__())  # 一次要100件衣服中的20件
# print(gen.__next__()) #衣服 1   #生产第1件衣服  第1次返回
# print(gen.__next__()) #衣服 2   #生产第2件衣服  第2次返回
# print(gen.__next__()) #衣服 3   #生产第3件衣服  第3次返回
# print(gen.__next__()) #衣服 4   #生产第4件衣服  第4次返回
print('-------------------6 生产100件衣服--生成器方式--正确写法 要20件衣服-方法1')

#7 生产100件衣服--生成器模式（要一件生产一件，不占用库房，节约内存）--正确写法  推荐2
def func3():
    for i in range(1,101):
        yield ('衣服 %s' % i)
gen = func3()  #生成器函数后面加()，不是函数执行，而是产生一个生成器对象（类比：订单）

# for i in gen: #将所有100件衣服，通过for循环依次生产出来
#     print(i)
for i in range(len(gen)):  #通过生成器的索引，进行for循环
    if  i==20:
        break
    print(i)  #先只生产前20件衣服
print('-------------------7 生产100件衣服--生成器方式--正确写法 要20件衣服-方法2')





