#!/usr/bin/env python
#-*- coding:utf-8 -*-

# # 4. 车牌区域划分, 现给出以下车牌. 根据车牌的信息, 分析出各省的车牌持有量.
cars = ["鲁A32444","鲁B12333","京B8989M","黑C46555","沪B25041"]
dic2 = {"沪":"上海","黑":"黑龙江","鲁":"山东","京":"北京"}
# #结果输出 {"黑龙江":1,"山东":2,"北京":1,"上海":1}
"""
思路：
可以in get方法 setdefault方法一共3种方法实现
逻辑要点：如果key在字典1-dic1不存在，就设置初始值1  #这个思路必须掌握--关键点
         如果key在字典1-dic1存在，就将value自增1  dic1[k2] += 1

"""

#方法1 get方法
#get 方式1   #推荐  最好理解
dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2
    if dic1.get(k2) == None:  #3如果字典3不存在这个k2，就设置初始值1，添加键值对到字典3
        dic1[k2] = 1
    else: #4如果字典3存在这个k2，就自增1   dic1[k2] += 1   #关键点
        #v2的表示方式是2个，方式1是value，1，写死了；方式2是用字典的键来表示 ，dic1[k2]，这个就不是写死的  3关键点
        dic1[k2] += 1
    """
    循环过程：
    # 第1次，鲁A32444进来，if分支--将k2=山东 v2=1键值对添加到字典1 {"山东":"1"}
    # 第2次，鲁B12333进来，else分支-v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加到字典1 {"山东":"2"}
    # 第3次，京B8989M进来，if分支--将k2=北京 v2=1键值对添加到字典1 {"山东":"2", "北京":"1"}
    """

print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------1-get1")

#get 方式2
dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2

    v2 = dic1.get(k2,0)  #如果k2不存在，默认设置初始值是0；如果k2存在，就获取k2对应的value-v2
    v2 += 1  #自增1
    dic1[k2] = v2  #将k2和v2作为键值对，添加到字典1   #下面的过程  是重点
    # 第1次，鲁A32444进来，v2是0，v2自增1后是1，将k2=山东 v2=1键值对添加都字典1 {"山东":"1"}
    # 第2次，鲁B12333进来，v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加都字典1 {"山东":"2"}
    # 第3次，京B8989M进来，v2是0，v2自增1后是1，将k2=北京 v2=1键值对添加都字典1 {"山东":"2", "北京":"1"}

print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------1-get2")

#get 方式3
dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2

    # v2 = dic1.get(k2,0)  #如果k2不存在，默认设置初始值是0；如果k2存在，就获取k2对应的value-v2
    # v2 += 1  #自增1
    dic1[k2] = dic1.get(k2,0) + 1  #将k2和v2作为键值对，添加到字典1   #下面的过程  是重点
    # 第1次，鲁A32444进来，v2是0，v2自增1后是1，将k2=山东 v2=1键值对添加都字典1 {"山东":1}
    # 第2次，鲁B12333进来，v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加都字典1 {"山东":2}
    # 第3次，京B8989M进来，v2是0，v2自增1后是1，将k2=北京 v2=1键值对添加都字典1 {"山东":2, "北京":1}
    """
     第1次，鲁A32444进来，k2在dic1中不存在，就设置成0，加1后就是1，v2=1，将k2=山东 v2=1键值对添加到字典1  {"山东":1}
     第2次，鲁B12333进来，k2在dic1中存在，v2是1，加1后就是2，v2=2，将k2=山东 v2=2键值对添加到字典1  {"山东":2}
     第3次，京B8989M进来，k2在dic1中不存在，就设置成0，加1后就是1，v2=1，将k2=北京 v2=1键值对添加到字典1
      {"山东":2, "北京":1}
    """

print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------1-get3")

#方法2 in字典 方法   #推荐好理解
cars = ["鲁A32444","鲁B12333","京B8989M","黑C46555","沪B25041"]
dic2 = {"沪":"上海","黑":"黑龙江","鲁":"山东","京":"北京"}

dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2
    if k2 not in dic1:  #3如果字典3不存在这个k2，就设置初始值1，添加键值对到字典3
        dic1[k2] = 1
    else: #4如果字典3存在这个k2，就自增1   dic1[k2] += 1
        dic1[k2] += 1
    """
     循环过程：
     # 第1次，鲁A32444进来，if分支--将k2=山东 v2=1键值对添加到字典1 {"山东":"1"}
     # 第2次，鲁B12333进来，else分支-v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加到字典1 {"山东":"2"}
     # 第3次，京B8989M进来，if分支--将k2=北京 v2=1键值对添加到字典1 {"山东":"2", "北京":"1"}
     """
print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------2-in")

#方法3 setdefault方法
#方式1 setdefault方法
cars = ["鲁A32444","鲁B12333","京B8989M","黑C46555","沪B25041"]
dic2 = {"沪":"上海","黑":"黑龙江","鲁":"山东","京":"北京"}

dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2
    v2 = dic1.setdefault(k2,0)  #如果k2，不存在，将k2和1作为键值对添加到字典1；并且把value返回
                                #如果k2，存在，将不操作（不覆盖）
    v2 += 1   #将value返回后，自增1
    dic1[k2] = v2  #将k2和v2作为键值对 添加到字典1（如果k2存在就覆盖其value）
    """
    循环的过程：  重点掌握  关键思路过程
    # 第1次，鲁A32444进来，v2是0，v2自增1后是1，将k2=山东 v2=1键值对添加都字典1 {"山东":"1"}
    # 第2次，鲁B12333进来，v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加都字典1 {"山东":"2"}
    # 第3次，京B8989M进来，v2是0，v2自增1后是1，将k2=北京 v2=1键值对添加都字典1 {"山东":"2", "北京":"1"}
     """
print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------3-setdefault-1")

#方式2 setdefault方法   最简洁
cars = ["鲁A32444","鲁B12333","京B8989M","黑C46555","沪B25041"]
dic2 = {"沪":"上海","黑":"黑龙江","鲁":"山东","京":"北京"}

dic1 = {}
for i in cars:
    k1 = i[0]  #鲁  #1先获取列表中元素的首位--省的简称
    k2 = dic2[k1]  #山东  #2根据省的简称作为key，取字典2中取出器对应的value，把这个value作为字典3的k2
    # v2 = dic1.setdefault(k2,0)  #如果k2，不存在，将k2和1作为键值对添加到字典1；并且把value返回
    #                             #如果k2，存在，将不操作（不覆盖）
    # v2 += 1   #将value返回后，自增1
    dic1[k2] = dic1.setdefault(k2,0) +1  #如果k2不存在，v2就是1，将k2和1作为键值对添加到字典1
                                        #如果k2在字典1已经存在，就获取到k1对应的value值-v1，自增1后
                                        #将k2和1作为键值对添加到字典1
    """
    循环的过程：  重点掌握  关键思路过程
    # 第1次，鲁A32444进来，v2是0，v2自增1后是1，将k2=山东 v2=1键值对添加都字典1 {"山东":"1"}
    # 第2次，鲁B12333进来，v2是1，v2自增1后是2，将k2=山东 v2=2键值对添加都字典1 {"山东":"2"}
    # 第3次，京B8989M进来，v2是0，v2自增1后是1，将k2=北京 v2=1键值对添加都字典1 {"山东":"2", "北京":"1"}
     """
print(dic1)  #{'上海': 1, '黑龙江': 1, '山东': 2, '北京': 1}
print("------------3-setdefault-2")

#扩展
#方法4
# # 4. 车牌区域划分, 现给出以下车牌. 根据车牌的信息, 分析出各省的车牌持有量.
cars = ["鲁A32444","鲁B12333","京B8989M","黑C46555","沪B25041"]
dic2 = {"沪":"上海","黑":"黑龙江","鲁":"山东","京":"北京"}
# #结果输出 {"黑龙江":1,"山东":2,"北京":1,"上海":1}

"""
思路：
1、先循环列表，把列表的每个元素的首位，重新添加到列表1
2、将列表1去重，转换成set集合
3、循环遍历集合，统计每个元素在列表中出现的次数 li1.count(i)
4、新建空字典1（集合的for循环外）
5、将dic2[i]作为k1（根据省的简称，得到省的全称）
    将每个元素在列表中出现的次数 li1.count(i)作为v1，
    k1和v1作为键值对，添加到字典1
"""

li1 = []
for i in cars:
    li1.append(i[0])
print(li1)  #['鲁', '鲁', '京', '黑', '沪']

set1 = set(li1)  #2列表转换成set，去重
print(set1)  #{'沪', '鲁', '黑', '京'}

dic1 = {}
for i in set1:
    k1 = dic2[i]  #3根据省简称，取出省的全名，作为字典1的k1
    # print(k1,li1.count(i))
    dic1[k1] = li1.count(i)  #将列表中每个元素出现的次数，作为字典1的v1  #关键点
print(dic1)  #{'北京': 1, '山东': 2, '黑龙江': 1, '上海': 1}







