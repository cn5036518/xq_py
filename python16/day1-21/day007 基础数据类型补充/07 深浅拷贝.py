#!/usr/bin/env python
#-*- coding:utf-8 -*-

#1  引用传递--1个内存地址（列表、字典、集合通过等号赋值，传递的是内存地址，而不是值，一变都变）
li1 = [1,2,3,4]
li2 = li1
print(li2)  #[1, 2, 3, 4]
print(id(li1),id(li2)) #35447048 35447048   id相等，说明是同一个内存地址（同一个对象），一改都改，联动
li1.append("jack")
print(li1)  #[1, 2, 3, 4, 'jack']
print(li2)  #[1, 2, 3, 4, 'jack']
"""
现象和结论
1、通过li2 = li1 将列表1的值赋值给列表2
2、如果li1修改了，li2的值也随之修改

过程原因分析：
1、变量1-li1中存放的是列表的[1,2,3,4]的内存地址，比如“1a2b”
    变量1-li1和列表[1,2,3,4]在内存中是不同的两块内存空间
2、把变量1-li1赋值给变量2-li2，就是把内存地址"1a2b"，保存到了变量2-li2中
3、对变量1-li1的修改，实际上是对内存地址"1a2b"内容的修改
4、既然"1a2b"的内容修改了，那么变量2-li2也是指向内存地址"1a2b"的
   那么变量2也会随之修改

本质：变量1中只是存储的内存地址，而不是真正的列表，真正的列表存在别的内存空间
      变量2中也只是存储的内存地址--存储内存地址也叫引用存储（而不是值的存储）

通过等号进行直接赋值的2个变量
1、引用传递-存储引用（列表、字典、集合）--2个变量的修改，一变都变
2、值传递-存储值（字符串、整数）--2个变量的修改是独立的，不会一变都变

对于list, set, dict来说, 直接赋值. 其实是把内存地址交给变量（引用传递）. 并不是复制一份内容（值传递）.
所以.lst1的内存指向（引用传递）和lst2是一样的. lst1改变了, lst2也发生了改变
"""
print("--------------1 li2 = li1等号赋值是同一个内存地址")

# 一、浅拷贝
#1 方法1： 通过切片li1[:]  去全量复制
#  引用传递--2个不同内存地址  （切片，全部复制，是浅拷贝的第一种方法）
li1 = [1,2,3,4]
li2 = li1[:]  #li1[:]对比li1，是新开辟了一块内存空间（创建新的对象）
print(id(li1),id(li1[:]))  #35053000 35053192  关键点：
#  li1和li1[:]的值是相等的，都是[1,2,3,4],但是是不同的内存地址，即在内存中开辟了不同的内存空间
print(li2)  #[1, 2, 3, 4]
li1.append("jack")
print(li1)  #[1, 2, 3, 4, 'jack']
print(li2)  #[1, 2, 3, 4,]
"""
现象和结论
1、通过li2 = li1[:] 将列表1的切片（全部复制）形成的列表11的   值赋值给列表2
2、如果列表1修改了，列表2的值不会修改

过程原因分析：
1、变量1-li1中存放的是列表的[1,2,3,4]的内存地址，比如“1a2b”
    变量1-li1和列表[1,2,3,4]在内存中是不同的两块内存空间
2、把变量1-li1切片（全部复制后）形成的列表11（li[:]）的值是[1,2,3,4]
   但是列表11的内存地址变了，不是"1a2b",比如是"3c4d"
   把列表11-li1[:]赋值给变量2-li2，就是把内存地址"3c4d"，保存到了变量2-li2中
3、对变量1-li1的修改，实际上是对内存地址"1a2b"内容的修改
4、既然"1a2b"的内容修改了，那么变量2-li2也是指向内存地址"3c4d"的
   那么变量2就不会修改

本质：变量1中只是存储的内存地址，而不是真正的列表，真正的列表存在别的内存空间
      变量2中也只是存储的内存地址，但是这个内存地址和变量1中的内存地址是不同的
      所有两个变量（变量1和变量2的修改，不是联动的）

对于list, set, dict来说, 非直接赋值（切片后，全部复制，是新开辟了一块内存空间
变量1和变量2的值都是[1,2,3,4],但是内存地址是不同的）.
所以lst1的内存指向（引用传递）和lst2是不一样的. lst1改变了, lst2不会发生改变

浅拷贝的实现方法1：
1、通过切片li1[:]进行全量复制
2、切片后，新开辟了一个内存空间
3、因为是2个不同的内存空间，所有2个变量的操作是独立的，不会出现联动
    即li1修改了，li2是不会随之修改的
"""
print("--------------2 浅拷贝1切片  li2 = li1[:]")

# 浅拷贝方法2：
#  引用传递--2个不同内存地址  （ li1.copy()  是浅拷贝的第二种方法）
li1 = [1,2,3,4]
# li2 = li1[:]  #li1[:]对比li1，是新开辟了一块内存空间
li2 = li1.copy()  #copy（）是在内存中新开辟了一个内存空间（新创建了一个对象）
#a shallow copy of L 这里的li1和li2是2块不同的内存空间，虽然两个列表的只相同，都是[1,2,3,4]
#类比 copy() 考试抄作业，最后是2份答题试卷（内存地址、内存空间），虽然内容相同，但是是2份答题试卷
#新开辟内存空间，就会产生不同的内存地址，内存地址是内存空间的编号
print(id(li1),id(li1.copy()))  #35053000 35053192  关键点：
#  li1和li1.copy()的值是相等的，都是[1,2,3,4],但是是不同的内存地址，即在内存中开辟了不同的内存空间
print(li2)  #[1, 2, 3, 4]
li1.append("jack")
print(li1)  #[1, 2, 3, 4, 'jack']
print(li2)  #[1, 2, 3, 4,]
print("--------------2 浅拷贝2   li2 = li1.copy()")
"""
浅拷贝的实现方法2：
1、通过li1.copy()进行复制
2、切片后，新开辟了一个内存空间
3、因为是2个不同的内存空间，所以2个变量的操作是独立的，不会出现联动
    即li1修改了，li2=li1.copy()是不会随之修改的

拷贝是创建新对象的一种方式，优点是：创建便捷，速度快
类比：是做作业快，还是抄作业快（后者快）
"""

#浅拷贝的特殊情况
li1 = [1,2,[11,22],3,4]
# li2 = li1[:]   #浅拷贝
li2 = li1.copy()   #浅拷贝  新开辟一块内存地址，新创建一个新对象（li1和li2的值是一样的，但是内存地址不同，是2个不同的对象）
print(id(li1[2]),id(li2[2]))  #34898952 34898952   第二层的id相同，说明是同一个对象（同一个内存地址）
li1[2].append(33)
print(li1)  #[1, 2, [11, 22, 33], 3, 4]
print(li2) #[1, 2, [11, 22, 33], 3, 4]
print("--------------3 浅拷贝3   修改第二层")
"""
浅拷贝特点：
1、既然li1和li2的值是一样的，但是内存地址不同，是2个不同的对象
2、那么对li的操作，应该不会改变li2的值
3、但是实际结果，却同时改变了li2--why？

原因分析：
1、因为浅拷贝值拷贝了第一层，第二层及以后层是没有拷贝的，
即li1和li2的第一层元素是不同的内存地址，但是li1和li2的第二层元素[11,22]是同一个内存地址（内存地址也拷贝过来了）
  ---关键点1，必须掌握
2、那么li1中对[11,22]做了修改，而li2中[11,22]和li1中的[11,22]不仅是值相同，内存地址都相同
   即第二层是同一个对象（没有新建对象-开辟新的内存空间），所以会联动
"""

"""
总结：
1、等号的赋值，是同一个对象，一改都改-联动的  li2 = li1
2、浅拷贝(方式1 li2 = li1[:];方式2 li2 = li1.copy())
    是2个不同的对象（虽然值相等，但是内存地址不同）
    修改第一层，2个对象是独立的，不会出现一改都改
3、浅拷贝，修改第二层，就会出现一改都改-联动
    因为，浅拷贝，只是在第一层上是2个不同的对象
    第二层拷贝的是内存地址，第二层还是指向同一个对象，因此，修改第二层，是一改都改-联动
4、深拷贝，除了第一层是不同的2个对象，第二层及第三层等都是不同的2个对象，（每一次的id值都不同）
  修改任何层次，都不会出现一改都改的联动

提炼：
# 赋值没有创建新对象。多个变量共享同一个对象   li2 = li1  （一改都改，联动）
# 浅拷贝。 会创建新对象。 新的对象中里面的内容不会被拷贝（还是指向同一个对象）（第二层一改都改，联动；第一层是独立的，不是联动）
  ( 方式1 li2 = li1[:];方式2 li2 = li1.copy())
# 深拷贝。 创建一个一摸一样的完全新的对象。 这个对象延伸出来的内容（第二层及更深层）也会跟着复制一份
  （每一层都是独立的，不是联动）

"""

#二 深拷贝
import copy   #1导入拷贝模块
li1 = [1,2,[11,22],3,4]
li2 = copy.deepcopy(li1)  #2 深拷贝
print(id(li1[2]),id(li2[2]))  #40056328 33304456   第二层的id不相同，说明不是同一个对象（第二层也是不同的对象）
li1[2].append(33)  #3 对li1的第二层进行修改
print(li1)  #[1, 2, [11, 22, 33], 3, 4]  #li1的第二层修改后，li2的第二层没有修改（没有出现一改都改的联动）
print(li2)  #[1, 2, [11, 22], 3, 4]
print("--------------4 深拷贝   修改第二层")

"""
总结2
1、等号赋值，没有新建对象，一改都改，联动
    li2 = li1
    类比：夫妻不aa，共有一个账户，此账户的余额一变动，夫妻账户都修改了
2、浅拷贝，第一层是新建对象了，第二层及以后是没有新建对象的，第二层及以后，一改都改，联动
   第一层修改后，不会一改都改，不联动，独立的
    li2 = li1[:]
    li2 = li1.copy()
    类比：夫妻各自有账户（第一层），还设置一个家庭账户共有（第二层），家庭账户的余额变动，夫妻都有影响
3、深拷贝,每一层都新建对象了，每一层修改后，不会一改都改，不联动，独立的
    import copy
    li2 = copy.deepcopy(li1)
    类比：夫妻aa，财务完全独立
"""

#课上练习，一步步分析  （贪吃蛇，吃尾巴，尾巴短一节，整个身子长一节，总长度不变）
a = [1,2]
a[1] = a #第一次，把[1,2]赋值给2  就是[1,[1,2]]
# 第二次  a = [1,[1,2]],把 [1,[1,2]]赋值给[1,2],就是 [1,[1,[1,2]]]
# 第三次  a = [1,[1,[1,2]]] ,把[1,[1,[1,2]]]赋值给[1,[1,2]]，就是[1,[1,[1,[1,2]]]]
# 依次循环下去
print(a)  #[1, [...]]




