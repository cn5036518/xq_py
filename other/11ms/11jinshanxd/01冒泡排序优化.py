#!/usr/bin/env python
#-*- coding:utf-8 -*-

#1 冒泡排序--普通版
li1 = [1,4,2,3]
for i in range(len(li1)):
    for j in range(len(li1)-i-1):
        if li1[j] > li1[j+1]:
            li1[j],li1[j+1] = li1[j+1],li1[j]
print(li1)   #[1, 2, 3, 4]

#2 冒泡排序--优化版
# 如果列表本身的原始依据是从小到大排序好的，如何简化前面普通版的2个for循环的时间复杂度
"""
优化思路：--标记位flag思想
1、采用标记为flag,初始值是False或者0（位置在外循环内，内循环之外）
2、如果相邻数的两两比对有互换，就将flag从False置为True（0,1）
3、互换之后，如果flag还是False，说明不需要互换了（即已经排序完成了），--（位置在内循环同级的位置）
   break外循环即可
4、这样就可以在列表本身是从小到大已经排序（初始即排序好了或者是循环几次内循环就排序好了）的情况下，
   做外循环了
"""
li1 = [1,4,2,3]
for i in range(len(li1)):
    flag = False #0   #1关键点1  --标记位思想（在外循环内，内循环外）
    for j in range(len(li1)-i-1):
        if li1[j] > li1[j+1]:
            li1[j],li1[j+1] = li1[j+1],li1[j]
            flag = True  #1  #2关键点2   如果有互换，就把标记位从False改成True
    if flag == False:   # 关键点3 如果标记位还是原来的False，说明内循环中没有互换，（位置和内循环同级）
        #即内循环后，列表已经是从小到大的排序了，外循环就可以停止了break（因为没有必要再进行外循环了）
        break  #4 退出整个外循环
print(li1)   #[1, 2, 3, 4]
"""
思路过程：
1、每次外循环，都会重置标记位flag为False-0
2、每个内循环结束，都会将标记位flag改成True-1
3、如果内循环结束后(一次外循环)，标记位flag变成了True，说明进行过互换，
   应该继续外循环，进行下一次内循环
4、如果内循环结束后（一次外循环），标记位还是初始值False，说明本轮内循环没有进行过元素互换，
   没有元素互换，说明列表的元素已经是从小到大排序了
5、在内循环的同级，判断如果flag还是False，那么就退出整个外循环（-break）
   因为列表的元素已经排序好了，就不必要做外循环多余的循环了

时间复杂度：
概念：时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
1、每多一层for循环，就会增加时间复杂度
2、时间复杂度是程序运行完毕的时间/数据量的比值

空间复杂度：
概念：空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

"""

#扩展题：
#int这个内置函数的底层算法--把字符串"123"通过int转换成数字123的底层算法
"""
思路分析：
1、字符串"000123"转换成数字123的时候，需要去掉前面的0
2、当字符串的位数在-2**31到2*31之外（32位电脑）时，应该return异常
    1、比如大于200位越界，那么等于200位，如何判断是否越界（超出范围）
3、考虑字符串的元素如果不是数字，比如特殊字符，字母等，应该return异常
4、正常的时候，应该return数字
5、当字符串是-号开头的时候，不能抛异常等
"""










