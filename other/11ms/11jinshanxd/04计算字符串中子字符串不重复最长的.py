#!/usr/bin/env python
#-*- coding:utf-8 -*-

s1 = "abcddddas"
#需求：计算字符串中，子字符串中每个字符都不重复的时候，最大长度的子字符串

# 题目描述#
# 给定一个字符串，请找出其中无重复字符的最长子字符串。#
# 样例
# 例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。
# 对于，”bbbbb”，其无重复字符的最长子字符串为”b”，长度为1。

"""
思路：
1、循环遍历字符串
2、通过空字符串进行拼接
3、拼接前，先判断一下，如果新的字符已经在之前拼接的字符串中
   就需要将之前拼接的字符串的第一次出现的字符，切片切出去
4、然后接着拼接
"""
s0 = ""
dic1 = {}
for i in range(len(s1)):
    if s1[i] not in s0:  #不在拼接字符串，就拼接
        s0 = s0 + s1[i]
    else:  #2 如果已经在拼接字符串。就需要将之前拼接的字符串的第一次出现的字符（及它之前的字符），切片切出去
        index1 = s0.index(s1[i]) #3 计算第二次出现字符a的时候，字符a第一次在已经拼接字符串的位置-索引号
        s0 = s0[index1+1:] #4 将字符a第一次出现的位置，即位置之前的字符，切片切出去（这里必须通过索引实现） --关键段
        s0 = s0 + s1[i] #5 继续拼接字符串
    dic1[s0] = len(s0)  #关键点:将不重复的字符串和其长度分别作为key和value添加到空字典中
print(s0)    #das   问题是：abcd比das要长，但是abcd被切片切出去了  这个必须修正
print(dic1)  #{'ab': 2, 'abcd': 4, 'abc': 3, 'das': 3, 'a': 1, 'da': 2}

# 如何给字典进行排序，用字典的value进行排序
#方法1：  --Counter
from collections import Counter
dic11 = Counter(dic1)  #参数是可迭代类型（字符串、列表、字典、集合，元组）
print(dic11)  #Counter({'abcd': 4, 'das': 3, 'abc': 3, 'da': 2, 'ab': 2, 'a': 1})
#参数是字典，Counter可以实现按照字典的value进行从大到小排序

s1 = "abcddddas"
dic12 = Counter(s1) #计算字符串中每个字符出现的次数，按照次数从大到小排序
print(dic12)  #Counter({'d': 4, 'a': 2, 's': 1, 'b': 1, 'c': 1})

# 方法2  通过匿名函数--重点（实现字典，按照字典的value从大到小的排序）
li11 = sorted(dic1.items(),key=lambda x:x[1],reverse=True)  #倒序
li12 = sorted(dic1.items(),key=lambda x:x[1],reverse=False)  #升序
print(li11)  #[('abcd', 4), ('das', 3), ('abc', 3), ('da', 2), ('ab', 2), ('a', 1)]
print(li12) #[('a', 1), ('ab', 2), ('da', 2), ('das', 3), ('abc', 3), ('abcd', 4)
#sorted后面的参数1是字典的项目items，参数2是key-匿名函数lamdba，参数3是是否倒序
print("-------------方法2")

# 方法3   （实现字典，按照字典的value从大到小的排序）--算法
"""
思路：--算法
如何实现，按照字典的value从小到大排序
方法1: 通过Counter内置函数实现--从大到小的排序
方法2：通过sorted函数，参数2是匿名函数来实现
方法3：通过冒泡排序算法来实现
        1、把字典的键值对的key和value，作为元素添加到子列表，子列表整体作为元素添加到大列表
            # li3 = [[5, 'ab'], [4, 'abcd'],[1, 'abcd']]
        2、冒泡排序是将列表中的元素数字进行排序，li[i]>li[i+1]
            这里是将大列表的中元素小列表的第一个元素-数字进行排序  li[i][0]>li[i+1][0]
"""
dic2 = {'ab': 2, 'abcd': 4, 'abc': 3, 'das': 3, 'a': 1, 'da': 2}
li3 = []
for i in dic2:
    li12 = [dic2[i],i]
    li3.append(li12)   #1 先把字典的每个键值对中的key和value，作为一个列表，整个列表作为大列表的一个元素
print(li3)  #[[2, 'da'], [4, 'abcd'], [3, 'das'], [1, 'a'], [2, 'ab'], [3, 'abc']]

# li3 = sorted(li3,key=lambda x:x[0],reverse=True)  #用sorted和匿名函数，实现对列表中的子列表的元素1进行排序
# print(li3)  #[(4, 'abcd'), (3, 'abc'), (3, 'das'), (2, 'ab'), (2, 'da'), (1, 'a')]

# li3 = [[5, 'ab'], [4, 'abcd'],[1, 'abcd']]
# 2如何实现对于大列表中的子列表，按照子列表的元素1进行排序----算法（冒泡排序）
s1 = "abcddddas"
for j in range(len(li3)):
    flag = False #0
    for i in range(len(li3)-j-1): #0-5   #注意点：这里的-1是为了解决下面的索引越界问题，-j是为了减少时间复杂度
        if li3[i][0] > li3[i+1][0]:  #最大数放在最右边
        # if li3[i][0] < li3[i+1][0]:   #最大数放在最左边
            li3[i][0],li3[i+1][0] = li3[i+1][0],li3[i][0]
            flag = True  #1
    if flag == False:  #注意点2：标记位flag是为了判断，当列表已经是从小到大排序好了后，就不用再循环遍历了，性能优化
        break  #退出外循环
print(li3)  #[[1, 'abcd'], [2, 'abc'], [2, 'a'], [3, 'ab'], [3, 'da'], [4, 'das']]
print("字符串%s中,无重复字符的最长子字符串是%s，其长度为%s" % (s1,li3[-1][1],li3[-1][0]))
#字符串abcddddas中,无重复字符的最长子字符串是abcd，其长度为4

"""
总结
读清楚题目：
# 给定一个字符串，请找出其中无重复字符的最长子字符串。#
# 例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。
# 对于，”bbbbb”，其无重复字符的最长子字符串为”b”，长度为1。

思路总结：
一、找到字符串中所有的无重复字符的子字符串，--如何实现？（关键点）
    将子字符串和其长度分贝作为key和value添加到空字典
0、建立一个空字符串s0
1、循环遍历字符串s1,通过索引号
2、如果字符i不在s0中，就累计拼接s0 = s0 +s1[i]
3、如果字符i在s0中，就计算出字符第一次出现在s1中的索引号--index
   将索引号及之前的字符串，切片出去
   继续累计拼接
4、找到是s1中所有的不重复的子字符串s0后，
   将s0和s0的长度作为key和value，依次添加到空字典
二、如何计算字典中，按照字典的value进行倒序排列
   #{'d': 1, 'da': 2, 'a': 1, 'abcd': 4, 'abc': 3, 'das': 3, 'ab': 2}
方法1：通过collection模块下的counter，可以直接实现从大到小排序
方法2：通过sorted函数，参数1是字典的items，参数2是key=lambda x:x[1] 匿名函数，参数3是reverse
方法3、冒泡排序算法
       1、把字典的键值对，key和value添加到子列表，子列表组成大列表
            [[2, 'da'], [3, 'das'], [1, 'a'], [4, 'abcd'], [3, 'abc'], [2, 'ab']]
        2、普通的冒泡排序，是按照列表的元素数字进行排序  li[i]>li[i+1]
           这里需要按照列表的元素的第一个元素-数字进行排序  li[i][0]>li[i+1][0]


"""




















