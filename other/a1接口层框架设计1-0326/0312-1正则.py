#!/usr/bin/env python
# -*- coding:utf-8 -*-

'''
@author: jack
@license: (C) Copyright 2013-2017, Node Supply Chain Manager Corporation Limited.
@contact: cn5036520@163.com
@software: sign
@file: 0312-1正则.py
@time: 2018/12/3 6:09
@desc:
'''

"""
一、正则表达式概念
1、什么是正则表达式？--what
    它是一种小型的、高度专业化的编程语言
2、为什么要学习正则表达式？--why
    它是一种通用语言，主要用于字符串处理
3、正则表达式的写法--how
    在python中通过re模块实现
    import re

二、在线正则表达式测试
作用：验证你写的正则表达式是否正确
http://tool.oschina.net/regex/

三、正则表达式速查表
http://www.jb51.net/shouce/jquery1.82/regexp.html
"""

"""
1、字符匹配-普通字符
    大多数字符和自身完全匹配
    例如：表达式jack与字符串"jack"完全匹配
2、字符匹配-元字符（需要背下来）
    ^ 匹配行首
    $ 匹配行尾

    * 将前一字符匹配大于等于0次  >=0
    ? 将前一字符匹配0次或者1次（表示是否出现）  0或者1次
    + 将前一字符匹配大于等于1次  >=1

    . 匹配任意单字符（除了换行符以外）
    \ 将元字符转义为普通字符  \\  \^ \$  \* \[

    [] 指定一个字符集[a-zA-Z0-9]
        （或的关系，比如[abc]表示出现a或b或c 其他同理）
        还可以匹配不在区间范围内的字符[^5](非5的)，注意这里必须使用[]

    常用
    \d 匹配一个数字字符。等价于[0-9]
        \d+ 匹配一个或者多个数字
        \d* 匹配0个或者多个数字
        \d? 匹配0个或者1个数字

    {} 重复次数
    |  表示或 x|y代表匹配x或y
    () 分组，即看为一个整体
"""

"""
小结
一、常用元字符
    . 匹配任意字符（除了换行符以外）
    ^ 匹配字符串的开始
    $ 匹配字符串的结束
    \d 匹配数字    等价于[0-9]

    \b 匹配单词的开始或者结束
    \w 匹配字母、数字、下划线（或）
    \s 匹配任意空白符
        （包括空格\0、
          制表符\t \v、
          换页符\f、
          回车换行符\r\n）

二、常用限定符
    * 重复0次或者多次
    + 重复1次或者多次
    ? 重复0次或者1次
    {n} 重复n次
    {n,} 重复n次或者更多次
    {n,m} 重复n到m次

三、常用反义词
    [^x]  匹配除了x之外的任意字符
    [^aeiou] 匹配除了aeiou之外的任意字符
    注意：单纯^ 匹配行首
        如果^和[]组合使用，就是取反义的意思
"""

"""
课上练习1：
1、匹配下面字符串中的数字
   one1two2three3
   正则该怎么写？

答案：
\d+ （推荐，最简洁）     注意：不能是\d*（0个或者多个数字，0个数字也会匹配出来）,也不能是\d?
或者[0-9]
或者\d
或者[1-3]、[123]  注意：这个[1-3]虽然对，但是不具备通用性，如果出现4-9的数字，就不适合，应该换成[0-9]更具有通用性

重点：
1、老师讲课的思路
2、做题（解题、做练习）的思路


2、匹配下面字符串中的数字
   one12two2three3,注意：12需要两位一起匹配出来，而不是1,2分开匹配
   正则该怎么写？

答案：
\d+ （推荐，最简洁）
或者[0-9]+ 或者\d{1,3} [0-9]{1,3}
注意：
1、不能是\d*（0个或者多个数字，0个数字也会匹配出来）,
2、也不能是\d?
3、也不能是[0-9] \d   （匹配结果是1，2不是两位一起匹配的，而是1,2分开匹配的）
4、不能是\d{0,3}  (0个数字也会匹配出来)


课上练习2
1、匹配下面字符串中的aaaa
   aaaabbbccc
   正则该怎么写？

答案：
a{4}或者a{1,4}
注意：
不能是a{0-4}  (0个a也会匹配出来)


课上练习3
1、正则 c|d,匹配字符串"abcd"，结果？
    答案：  c d
    c|d表示匹配c或者d
2、正则：(ab),匹配字符串"abc adc abb"，结果？
    答案： ab ab
    (ab)表示把ab看为一个整体，来进行匹配


{} 重复次数
|  表示或 x|y代表匹配x或y
() 分组，即看为一个整体


课上练习4
["AD123456","AC343456","AR453456"]
上述3个字符串，匹配出 2个大写字母和6个数字

答案：
方式1：
\w+\d+（最简短）   [A-Z]+\d+
这里\d+ 匹配1个或者多个数字，可以匹配出后面6个数字
这里\w+ 匹配1个或者多个字母、数字或者下划线（或的关系），可以匹配2个大写字母

方式2：
[A-Z]{2}[0-9]{6}（最直观，直译）     [A-Z]{2}\d{6}(推荐，最准确）  [A-Z]+\d+
这里[A-Z]{2}表示，匹配2个大写字母
这里[0-9]{6}表示，匹配6个数字

思路：将题目2个大写字母和6个数字 转换成 正则表达式
    2个-{2}-大写字母-[A-Z]和6个-{6}-数字-[0-9]

课上练习5
用正则表达式匹配中国国内的手机号码
1、1开头
2、全部数字
3、一共是11位

1(3|5|7|8)\d{9}   #(3|5|7|8) 这里|表示或   |  表示或 x|y代表匹配x或y    () 分组，即看为一个整体
1[3578]\d{9}     #[3578]   或的关系，比如[abc]表示出现a或b或c  \d{9}表示9位数字
1[3578]\d{9}\s   #解决手机号的换行问题 \s匹配任意空白符  注意：最后一个手机号也需要多一个换行
                                （包括空格\0、
                                      制表符\t \v、
                                      换页符\f、
                                      回车换行符\r\n）

"""
import re
str1 = "one1two2three3"

#一、match函数 匹配字符串的开头（即字符串的开头是否符合正则表达式）
print(re.match("www","wwwcom").group()) #www  参数1是正则表达式，参数2是待匹配的字符串  group()是显示匹配后的结果,可视化
print(re.match("www","wwwcom"))  #<_sre.SRE_Match object; span=(0, 3), match='www'>
                                # 没有group()方法的话，匹配的结果是一个坐标，不直观
print(re.match("www","22wwwcom")) #None 如果没有匹配到的话，返回None
print(type(re.match("www","wwwcom"))) #<class '_sre.SRE_Match'>
# print(re.match("www","22wwwcom").group()) #如果没有匹配到的话，返回None后在调用group()方法，会报错；group（）只有匹配到后，才能调用
# AttributeError: 'NoneType' object has no attribute 'group'

print(re.match("1[3578]\d{9}","13501145281").group()) #匹配手机号成功
print(re.match("1[3578]\d{9}","1113501145281")) #None #匹配手机号不成功 因为字符串的开头不符合正则表达式
print("=====================match函数")

#二、search函数 匹配字符串的全部，并且返回第一个符合条件的字符串（从左到右）
print(re.search("www","22wwwcom").group()) #www  扫描字符串全部
# 参数1是正则表达式，参数2是待匹配的字符串  group()是显示匹配后的结果,可视化
print(re.search("1[3578]\d{9}","111350114528113501145282").group()) #13501145281  只返回第一个符合条件的字符串
print(re.search("1[3578]\d{9}","1113501145281")) #<_sre.SRE_Match object; span=(2, 13), match='13501145281'> 返回坐标位移等
print("====================search函数")

#三、findall函数  匹配字符串的全部，并且将所有匹配到的字符串作为列表的元素，返回列表  不需要group()方法
print(re.findall("1[3578]\d{9}","111350114528113501145282")) #不需要group()方法
print(re.findall("www","ww2wcom")) #[]
# ['13501145281', '13501145282']
# print(re.findall("1[3578]\d{9}","111350114528113501145282").group()) #
# AttributeError: 'list' object has no attribute 'group'  #列表没有group（）方法，但是字符串有group（）方法
print(re.findall("\d+","one1two2three3"))  #['1', '2', '3']
print(re.findall("\d+","one1twothree"))  #['1']
print("====================findall函数")

#四、compile函数 性能更好
p = re.compile("\d+")  #compile先将正则表达式进行编译，编译后执行速度更快
print(p.findall("one1two2three34"))  #['1', '2', '34']
print("====================compile函数")

#五、sub函数   替换字符串
print(re.sub("g..t","jack","gaat gbbt")) #jack jack #这里参数1的点表示任意字符
# #用参数1的正则，匹配参数3中的字符串，用参数2的字符串替换参数3中符合正则的部分，返回字符串
#参数1是正则表达式，参数2是源字符串，参数3是待替换字符串
print("====================sub替换函数")

#六、split函数 分割字符串
print(re.split("\+","123+abc")) #['123', 'abc'] #这里加号前面的斜杠是转义符，返回列表
#参数1是正则表达式，参数2是待匹配的字符串，将参数1中的正则作为分隔符，将参数3中的字符串进行分割，分割后的字符串作为列表的元素
print(re.split("\+","123+abc+456")) #['123', 'abc', '456']
print(re.split("\+","123+abc+456",1)) #['123', 'abc+456']
print("====================split分割函数")

"""
match、search和findall的区别（相同点和不同点）
相同点：
1、都是参数1是正则表达式，参数2是待匹配的字符串
2、match和search都要调group方法，才能显示字符串
3、如果没有匹配到，match和search都会返回None;
    返回None的时候，如果调group方法，就会报错

不同点：
1、match函数是匹配字符串的开头
    不调group方法，返回的是坐标位移；调group()方法后，返回符合条件的字符串
2、search函数是匹配字符串的全部，返回第一个符合要求的字符串（第二个符合要求的就不返回了）
    不调group方法，返回的是坐标位移；调group()方法后，返回符合条件的字符串
3、findall函数是匹配字符串的全部，将所有符合要求的字符串作为列表的元素，返回列表
    列表没有group方法，不需要调group()
    如果没有匹配到，就返回空列表[]



"""

















